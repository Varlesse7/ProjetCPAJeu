{"ast":null,"code":"import FastPriorityQueue from \"fastpriorityqueue\";\nimport * as conf from './conf';\n// Mur de droite = 1 et Mur haut = 0 et Mur gauche = 2  \n\nconst randomInt = max => Math.floor(Math.random() * max);\nconst randomSign = () => Math.sign(Math.random() - 0.5);\nconst dist2 = (o1, o2) => Math.pow(o1.x - o2.x, 2) + Math.pow(o1.y - o2.y, 2);\nconst iterate = bound => ball => {\n  return {\n    ...ball,\n    coord: {\n      ...ball.coord,\n      x: ball.coord.x + ball.coord.dx,\n      y: ball.coord.y + ball.coord.dy\n    }\n  };\n};\nconst mouvDebris = bound => ball => {\n  return {\n    ...ball,\n    coord: {\n      ...ball.coord,\n      x: ball.coord.x + ball.coord.dx,\n      y: ball.coord.y + ball.coord.dy\n    }\n  };\n};\nconst mouvTirD = bound => ([i, rect]) => {\n  let newdy = rect.coord.dy;\n  if (rect.coord.y === 200) {\n    newdy = 0;\n  }\n  return [i, {\n    ...rect,\n    coord: {\n      ...rect.coord,\n      y: rect.coord.y + newdy,\n      dy: newdy\n    }\n  }];\n  ;\n};\n\n// üîπ Heuristique : Distance de Manhattan\nconst heuristique = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n\n// üîπ Algorithme A* modifi√©\nconst astar = (start, goal, bound) => {\n  const openSet = new FastPriorityQueue((a, b) => a.f < b.f);\n  openSet.add({\n    coord: start,\n    g: 0,\n    h: heuristique(start, goal),\n    f: heuristique(start, goal)\n  });\n  const closedSet = new Set();\n  const gScoreMap = new Map();\n  const cameFrom = new Map();\n  gScoreMap.set(`${start.x},${start.y}`, 0);\n  while (!openSet.isEmpty()) {\n    const current = openSet.poll();\n\n    // Condition d'arr√™t avec tol√©rance de 10px\n    if (Math.abs(current.coord.x - goal.x) <= 10 && Math.abs(current.coord.y - goal.y) <= 10) {\n      let path = [];\n      let temp = current;\n      while (temp) {\n        path.push(temp.coord);\n        temp = cameFrom.get(`${temp.coord.x},${temp.coord.y}`);\n      }\n      return path.reverse();\n    }\n    closedSet.add(`${current.coord.x},${current.coord.y}`);\n\n    // Voisins avec un pas de 4 pixels\n    for (const neighborCoord of getNeighbors(current, bound, 4)) {\n      const neighborKey = `${neighborCoord.x},${neighborCoord.y}`;\n      if (closedSet.has(neighborKey)) continue;\n      const tentativeGScore = current.g + 4; // Co√ªt bas√© sur la distance\n      if (!gScoreMap.has(neighborKey) || tentativeGScore < gScoreMap.get(neighborKey)) {\n        gScoreMap.set(neighborKey, tentativeGScore);\n        const hScore = heuristique(neighborCoord, goal);\n        const neighborNode = {\n          coord: neighborCoord,\n          g: tentativeGScore,\n          h: hScore,\n          f: tentativeGScore + hScore,\n          parent: current\n        };\n        openSet.add(neighborNode);\n        cameFrom.set(neighborKey, current);\n      }\n    }\n  }\n  return [];\n};\n\n// üîπ getNeighbors modifi√© pour un pas de 4\nconst getNeighbors = (node, bound, step = 4) => {\n  const {\n    x,\n    y\n  } = node.coord;\n  const moves = [{\n    x: x - step,\n    y,\n    dx: -step,\n    dy: 0\n  },\n  // Gauche\n  {\n    x: x + step,\n    y,\n    dx: step,\n    dy: 0\n  },\n  // Droite\n  {\n    x,\n    y: y - step,\n    dx: 0,\n    dy: -step\n  },\n  // Haut\n  {\n    x,\n    y: y + step,\n    dx: 0,\n    dy: step\n  } // Bas\n  ];\n  return moves.filter(n => n.x >= 0 && n.y >= 0 && n.x < bound.width && n.y < bound.height);\n};\n\n// üîπ Fonction de mouvement adapt√©e\nconst mouvAStar = (bound, hero) => {\n  let lastPath = [];\n  let lastGoal = null;\n  let isApproachingGoal = false;\n  return ball => {\n    const distanceToGoal = heuristique(ball.coord, hero);\n\n    // Si on est d√©j√† assez proche, on va directement vers le goal\n    if (distanceToGoal <= 20) {\n      isApproachingGoal = true;\n      const dx = Math.sign(hero.x - ball.coord.x) * 4;\n      const dy = Math.sign(hero.y - ball.coord.y) * 4;\n      return {\n        ...ball,\n        coord: {\n          x: ball.coord.x + dx,\n          y: ball.coord.y + dy,\n          dx,\n          dy\n        }\n      };\n    }\n\n    // Recalcul du chemin seulement si n√©cessaire\n    if (!lastGoal || heuristique(hero, lastGoal) > 50 || lastPath.length === 0) {\n      lastPath = astar(ball.coord, hero, bound);\n      lastGoal = {\n        ...hero\n      };\n      isApproachingGoal = false;\n    }\n    if (!isApproachingGoal && lastPath.length > 1) {\n      const nextStep = lastPath[1];\n      lastPath.shift();\n\n      // Lissage du mouvement\n      const dx = nextStep.x - ball.coord.x;\n      const dy = nextStep.y - ball.coord.y;\n      return {\n        ...ball,\n        coord: {\n          x: ball.coord.x + dx,\n          y: ball.coord.y + dy,\n          dx,\n          dy\n        }\n      };\n    }\n\n    // Fallback: mouvement direct si aucun chemin\n    const dx = Math.sign(hero.x - ball.coord.x) * 4;\n    const dy = Math.sign(hero.y - ball.coord.y) * 4;\n    return {\n      ...ball,\n      coord: {\n        x: ball.coord.x + dx,\n        y: ball.coord.y + dy,\n        dx,\n        dy\n      }\n    };\n  };\n};\n\n/*export const click =\n  (state: State) =>\n  (event: PointerEvent): State => {\n    const { offsetX, offsetY } = event\n    const target = state.pos.find(\n      (p) =>\n        dist2(p.coord, { x: offsetX, y: offsetY, dx: 0, dy: 0 }) <\n        Math.pow(conf.RADIUS, 2) + 100\n    )\n    if (target) {\n      target.coord.dx += Math.random() * 10\n      target.coord.dy += Math.random() * 10\n    }\n    return state\n  }*/\n\nconst collideBOC = (b, oc) => dist2(b, {\n  x: oc.coord.x,\n  y: oc.coord.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS + oc.radius, 2);\nconst collideROC = (h, oc) => {\n  const hx = h.coord.x;\n  const hy = h.coord.y;\n  const hw = h.hitBox.hx;\n  const hh = h.hitBox.hy;\n  const cx = oc.coord.x;\n  const cy = oc.coord.y;\n  const cr = oc.radius;\n  const nearestX = Math.max(hx - hw / 2, Math.min(cx, hx + hw / 2));\n  const nearestY = Math.max(hy - hh / 2, Math.min(cy, hy + hh / 2));\n  const distX = cx - nearestX;\n  const distY = cy - nearestY;\n  return distX * distX + distY * distY <= cr * cr;\n};\nconst collideHeroTir = (h, oc) => {\n  const hx = h.coord.x;\n  const hy = h.coord.y;\n  const hw = h.hitBox.hx;\n  const hh = h.hitBox.hy;\n  const cx = oc.coord.x;\n  const cy = oc.coord.y;\n  const cr = 5;\n  const nearestX = Math.max(hx - hw / 2, Math.min(cx, hx + hw / 2));\n  const nearestY = Math.max(hy - hh / 2, Math.min(cy, hy + hh / 2));\n  const distX = cx - nearestX;\n  const distY = cy - nearestY;\n  return distX * distX + distY * distY <= cr * cr;\n};\nconst collideEnnemieTir = (h, oc) => {\n  const hx = h.coord.x;\n  const hy = h.coord.y;\n  const hw = h.width;\n  const hh = h.height;\n  const cx = oc.coord.x;\n  const cy = oc.coord.y;\n  const cr = 5;\n  const nearestX = Math.max(hx, Math.min(cx, hx + hw));\n  const nearestY = Math.max(hy, Math.min(cy, hy + hh));\n  const distX = cx - nearestX;\n  const distY = cy - nearestY;\n  return distX * distX + distY * distY <= cr * cr;\n};\nconst collideBORR = (b, or) => dist2(b, {\n  x: or.rightBottom.x,\n  y: or.leftTop.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) || dist2(b, {\n  x: or.rightBottom.x,\n  y: or.rightBottom.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) || dist2(b, {\n  x: or.rightBottom.x,\n  y: b.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) && b.y > or.leftTop.y && b.y < or.rightBottom.y;\nconst collideBORL = (b, or) => dist2(b, {\n  x: or.leftTop.x,\n  y: or.rightBottom.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) || dist2(b, {\n  x: or.leftTop.x,\n  y: or.leftTop.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) || dist2(b, {\n  x: or.leftTop.x,\n  y: b.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) && b.y > or.leftTop.y && b.y < or.rightBottom.y;\nconst collideBORU = (b, or) => dist2(b, {\n  x: or.rightBottom.x,\n  y: or.leftTop.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) || dist2(b, {\n  x: or.leftTop.x,\n  y: or.leftTop.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) || dist2(b, {\n  x: b.x,\n  y: or.leftTop.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) && b.x > or.leftTop.x && b.x < or.rightBottom.x;\nconst collideBORB = (b, or) => dist2(b, {\n  x: or.leftTop.x,\n  y: or.rightBottom.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) || dist2(b, {\n  x: or.rightBottom.x,\n  y: or.rightBottom.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) || dist2(b, {\n  x: b.x,\n  y: or.rightBottom.y,\n  dx: 0,\n  dy: 0\n}) < Math.pow(conf.RADIUS, 2) && b.x > or.leftTop.x && b.x < or.rightBottom.x;\nconst collide = (o1, o2) => dist2(o1, o2) < Math.pow(2 * conf.RADIUS, 2);\nconst collideboing = (p1, p2) => {\n  const nx = (p2.x - p1.x) / (2 * conf.RADIUS);\n  const ny = (p2.y - p1.y) / (2 * conf.RADIUS);\n  const gx = -ny;\n  const gy = nx;\n  const v1g = gx * p1.dx + gy * p1.dy;\n  const v2n = nx * p2.dx + ny * p2.dy;\n  const v2g = gx * p2.dx + gy * p2.dy;\n  const v1n = nx * p1.dx + ny * p1.dy;\n  p1.dx = nx * v2n + gx * v1g;\n  p1.dy = ny * v2n + gy * v1g;\n  p2.dx = nx * v1n + gx * v2g;\n  p2.dy = ny * v1n + gy * v2g;\n  p1.x += p1.dx;\n  p1.y += p1.dy;\n  p2.x += p2.dx;\n  p2.y += p2.dy;\n};\nconst collideboingS = (p1, p2) => {\n  const nx = (p2.coord.x - p1.x) / (2 * conf.RADIUS);\n  const ny = (p2.coord.y - p1.y) / (2 * conf.RADIUS);\n  const gx = -ny;\n  const gy = nx;\n  const v1g = gx * p1.dx + gy * p1.dy;\n  const v1n = nx * p1.dx + ny * p1.dy;\n  p1.dx -= 2 * nx + gx * v1g;\n  p1.dy -= 2 * ny + gy * v1g;\n  p1.x += p1.dx;\n  p1.y += p1.dy;\n};\nexport const step = state => {\n  // Gestion du d√©lai de tir\n  const shootingDelay = 60;\n  if (state.shootCooldownHero <= 0) {\n    state.tirs.push({\n      life: 1,\n      coord: {\n        x: state.hero.coord.x,\n        y: state.hero.coord.y,\n        dx: 0,\n        dy: -2\n      }\n    });\n    state.shootCooldownHero = shootingDelay;\n  } else {\n    state.shootCooldownHero--;\n  }\n  state.ennemisQuiTire = state.ennemisQuiTire.map(([cooldown, ennemie]) => {\n    if (ennemie.coord.y == 200) {\n      if (cooldown <= 0) {\n        state.tirsEnnemie.push({\n          life: 1,\n          coord: {\n            x: ennemie.coord.x + 25,\n            y: ennemie.coord.y + 50,\n            dx: 0,\n            dy: 2\n          }\n        });\n        return [150, ennemie];\n      }\n      return [cooldown - 1, ennemie];\n    }\n    return [cooldown, ennemie];\n  });\n\n  //Gestion du d√©lai d'apparition d'ennemis\n  const appearanceDelay = 100;\n  if (state.ennemyDelay <= 0) {\n    switch (randomInt(2)) {\n      case 5:\n        //possibilit√© d'algo de gravit√©\n        state.debris.push({\n          coord: {\n            x: randomInt(window.innerWidth - (120 + 2 * conf.BOUNDLEFT)) + (60 + conf.BOUNDLEFT),\n            y: 0,\n            dx: 0,\n            dy: 2\n          },\n          radius: 25,\n          life: 2 // faire un truc en fonction du rayon pour la vie\n        });\n        break;\n      case 5:\n        state.ennemisQuiTire.push([150, {\n          coord: {\n            x: randomInt(window.innerWidth - (120 + 2 * conf.BOUNDLEFT)) + (60 + conf.BOUNDLEFT),\n            y: 0,\n            dx: 0,\n            dy: 1\n          },\n          width: 50,\n          height: 50,\n          life: 2 //possibilit√© de modifier la vie\n        }]);\n        break;\n      case 1:\n        state.ennemisVersHero.push({\n          coord: {\n            x: randomInt(window.innerWidth - (120 + 2 * conf.BOUNDLEFT)) + (60 + conf.BOUNDLEFT),\n            y: 0,\n            dx: 0,\n            dy: 2\n          },\n          radius: 25,\n          life: 2 // faire un truc en fonction du rayon pour la vie\n        });\n        break;\n      default:\n        break;\n    }\n    state.ennemyDelay = appearanceDelay;\n  } else {\n    state.ennemyDelay--;\n  }\n\n  //Collision d√©bris - tir\n  state.tirs.map(p1 => {\n    state.debris.map(c => {\n      if (collideBOC(p1.coord, c)) {\n        p1.life--;\n        c.life--;\n      }\n    });\n  });\n  state.tirsEnnemie.map(p => {\n    const coordH = state.hero.coord;\n    if (collideHeroTir(state.hero, p)) {\n      p.life = 0;\n      state.hero.vie--;\n    }\n  });\n  state.ennemisQuiTire.map(([_, r]) => {\n    state.tirs.map(p => {\n      if (collideEnnemieTir(r, p)) {\n        r.life--;\n        p.life = 0;\n      }\n    });\n  });\n  if (state.hero.vie == 0) {\n    state.hero.coord.x = 1;\n    state.endOfGame = true;\n  }\n\n  //Collision debri-h√©ros\n  state.debris.map(d => {\n    if (collideROC(state.hero, d)) {\n      d.life = 0;\n      state.hero.vie--;\n    }\n  });\n  return {\n    ...state,\n    tirs: state.tirs.map(iterate(state.size)).filter(p => p.coord.y > 0 && p.life > 0),\n    tirsEnnemie: state.tirsEnnemie.map(iterate(state.size)).filter(p => p.coord.y > 0 && p.life > 0),\n    debris: state.debris.map(mouvDebris(state.size)).filter(p => p.coord.y < window.innerHeight && p.life > 0),\n    ennemisQuiTire: state.ennemisQuiTire.map(mouvTirD(state.size)).filter(([_, rect]) => rect.coord.y < window.innerHeight && rect.life > 0),\n    ennemisVersHero: state.ennemisVersHero.map(mouvAStar(state.size, state.hero.coord)).filter(p => p.coord.y < window.innerHeight && p.life > 0),\n    endOfGame: state.endOfGame\n  };\n};\nexport const handleKeyPress = state => event => {\n  const stepx = state.hero.coord.dx;\n  const stepy = state.hero.coord.dy;\n  const ax = state.hero.coord.x;\n  const ay = state.hero.coord.y;\n  const hx = state.hero.hitBox.hx / 2;\n  const hy = state.hero.hitBox.hy / 2;\n  switch (event.key) {\n    case \"Z\":\n    case \"z\":\n      console.log(\"z\");\n      if (ay - stepy - hy > state.limite[0].rightBottom.y) {\n        return {\n          ...state,\n          hero: {\n            ...state.hero,\n            coord: {\n              ...state.hero.coord,\n              y: ay - stepy\n            }\n          }\n        };\n      }\n      return state;\n    case \"s\":\n    case \"S\":\n      console.log(\"s\");\n      if (ay + stepy + hy < state.limite[3].leftTop.y) {\n        return {\n          ...state,\n          hero: {\n            ...state.hero,\n            coord: {\n              ...state.hero.coord,\n              y: ay + stepy\n            }\n          }\n        };\n      }\n      return state;\n    case \"q\":\n    case \"Q\":\n      console.log(\"q\");\n      if (ax - stepx - hx > state.limite[1].rightBottom.x) {\n        return {\n          ...state,\n          hero: {\n            ...state.hero,\n            coord: {\n              ...state.hero.coord,\n              x: ax - stepx\n            }\n          }\n        };\n      }\n      return state;\n    case \"d\":\n    case \"D\":\n      console.log(\"d\");\n      if (ax + stepx + hx < state.limite[2].leftTop.x) {\n        return {\n          ...state,\n          hero: {\n            ...state.hero,\n            coord: {\n              ...state.hero.coord,\n              x: ax + stepx\n            }\n          }\n        };\n      }\n      return state;\n    default:\n      return state;\n  }\n};\nexport const mouseMove = state => event => {\n  return state;\n};\nexport const endOfGame = state => true;","map":{"version":3,"names":["FastPriorityQueue","conf","randomInt","max","Math","floor","random","randomSign","sign","dist2","o1","o2","pow","x","y","iterate","bound","ball","coord","dx","dy","mouvDebris","mouvTirD","i","rect","newdy","heuristique","a","b","abs","astar","start","goal","openSet","f","add","g","h","closedSet","Set","gScoreMap","Map","cameFrom","set","isEmpty","current","poll","path","temp","push","get","reverse","neighborCoord","getNeighbors","neighborKey","has","tentativeGScore","hScore","neighborNode","parent","node","step","moves","filter","n","width","height","mouvAStar","hero","lastPath","lastGoal","isApproachingGoal","distanceToGoal","length","nextStep","shift","collideBOC","oc","RADIUS","radius","collideROC","hx","hy","hw","hitBox","hh","cx","cy","cr","nearestX","min","nearestY","distX","distY","collideHeroTir","collideEnnemieTir","collideBORR","or","rightBottom","leftTop","collideBORL","collideBORU","collideBORB","collide","collideboing","p1","p2","nx","ny","gx","gy","v1g","v2n","v2g","v1n","collideboingS","state","shootingDelay","shootCooldownHero","tirs","life","ennemisQuiTire","map","cooldown","ennemie","tirsEnnemie","appearanceDelay","ennemyDelay","debris","window","innerWidth","BOUNDLEFT","ennemisVersHero","c","p","coordH","vie","_","r","endOfGame","d","size","innerHeight","handleKeyPress","event","stepx","stepy","ax","ay","key","console","log","limite","mouseMove"],"sources":["/home/ronald/Documents/STL-S2/CPA/ProjetCPAJeu/web/src/components/canvas/state.ts"],"sourcesContent":["import { useEffect } from 'react';\nimport FastPriorityQueue from \"fastpriorityqueue\";\nimport * as conf from './conf'\nexport type Coord = { x: number; y: number; dx: number; dy: number }\nexport type Point = {x:number; y: number}\ntype Ball = { coord: Coord; life: number; invincible?: number }\ntype Size = { height: number; width: number }\ntype Wall = { leftTop:Point, rightBottom:Point}\ntype ObjectCercle = {coord: Coord; radius: number; life: number}\nexport type Rectangle = {coord: Coord, width:number, height:number, life: number}\ntype Hero = {coord: Coord, hitBox: {hx: number, hy: number}, vie: number, force : number}\n\ntype Node = {\n  coord: Coord;\n  g: number; // Co√ªt depuis le d√©part\n  h: number; // Heuristique (distance estim√©e jusqu'√† la cible)\n  f: number; // f = g + h\n  parent?: Node;\n};\n\n// Mur de droite = 1 et Mur haut = 0 et Mur gauche = 2  \n\nconst randomInt = (max: number) => Math.floor(Math.random() * max)\nconst randomSign = () => Math.sign(Math.random() - 0.5)\n\nexport type State = {\n  hero : Hero\n  limite: Array<Wall>\n  size: Size\n  endOfGame: boolean\n  tirs: Array<Ball>\n  debris: Array<ObjectCercle>\n  ennemisQuiTire: Array<[number, Rectangle]>\n  ennemisVersHero: Array<ObjectCercle>\n  tirsEnnemie: Array<Ball>\n  shootCooldownHero : number\n  ennemyDelay : number\n}\n\nconst dist2 = (o1: Coord, o2: Coord) =>\n  Math.pow(o1.x - o2.x, 2) + Math.pow(o1.y - o2.y, 2)\n\nconst iterate = (bound: Size) => (ball: Ball) => {\n  \n  return {\n    ...ball, \n    coord: {\n      ...ball.coord,\n      x: ball.coord.x + ball.coord.dx,\n      y: ball.coord.y + ball.coord.dy,\n    },\n  }\n}\n\nconst mouvDebris = (bound: Size) => (ball: ObjectCercle) => {\n  \n  return {\n    ...ball, \n    coord: {\n      ...ball.coord,\n      x: ball.coord.x + ball.coord.dx,\n      y: ball.coord.y + ball.coord.dy,\n    },\n  }\n}\n\nconst mouvTirD = (bound: Size) => ([i, rect]: [number, Rectangle]) => {\n\n  let newdy = rect.coord.dy\n  if (rect.coord.y === 200) {\n    newdy = 0\n  }\n\n  return [\n    i,\n    {\n      ...rect,\n      coord: {\n        ...rect.coord,\n        y: rect.coord.y + newdy,\n        dy: newdy,\n      },\n    },\n  ]as [number, Rectangle];;\n}\n\n// üîπ Heuristique : Distance de Manhattan\nconst heuristique = (a: Coord, b: Coord): number => \n  Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n\n// üîπ Algorithme A* modifi√©\nconst astar = (start: Coord, goal: Coord, bound: Size): Coord[] => {\n  const openSet = new FastPriorityQueue<Node>((a, b) => a.f < b.f);\n  openSet.add({ \n    coord: start, \n    g: 0, \n    h: heuristique(start, goal), \n    f: heuristique(start, goal) \n  });\n\n  const closedSet: Set<string> = new Set();\n  const gScoreMap: Map<string, number> = new Map();\n  const cameFrom: Map<string, Node> = new Map();\n\n  gScoreMap.set(`${start.x},${start.y}`, 0);\n\n  while (!openSet.isEmpty()) {\n    const current = openSet.poll()!;\n\n    // Condition d'arr√™t avec tol√©rance de 10px\n    if (Math.abs(current.coord.x - goal.x) <= 10 && \n        Math.abs(current.coord.y - goal.y) <= 10) {\n      let path: Coord[] = [];\n      let temp: Node | undefined = current;\n      while (temp) {\n        path.push(temp.coord);\n        temp = cameFrom.get(`${temp.coord.x},${temp.coord.y}`);\n      }\n      return path.reverse();\n    }\n\n    closedSet.add(`${current.coord.x},${current.coord.y}`);\n\n    // Voisins avec un pas de 4 pixels\n    for (const neighborCoord of getNeighbors(current, bound, 4)) {\n      const neighborKey = `${neighborCoord.x},${neighborCoord.y}`;\n      if (closedSet.has(neighborKey)) continue;\n\n      const tentativeGScore = current.g + 4; // Co√ªt bas√© sur la distance\n      if (!gScoreMap.has(neighborKey) || tentativeGScore < gScoreMap.get(neighborKey)!) {\n        gScoreMap.set(neighborKey, tentativeGScore);\n        const hScore = heuristique(neighborCoord, goal);\n        const neighborNode = { \n          coord: neighborCoord, \n          g: tentativeGScore, \n          h: hScore, \n          f: tentativeGScore + hScore,\n          parent: current \n        };\n\n        openSet.add(neighborNode);\n        cameFrom.set(neighborKey, current);\n      }\n    }\n  }\n  return [];\n};\n\n// üîπ getNeighbors modifi√© pour un pas de 4\nconst getNeighbors = (node: Node, bound: Size, step: number = 4): Coord[] => {\n  const { x, y } = node.coord;\n  const moves: Coord[] = [\n    { x: x - step, y, dx: -step, dy: 0 }, // Gauche\n    { x: x + step, y, dx: step, dy: 0 },  // Droite\n    { x, y: y - step, dx: 0, dy: -step }, // Haut\n    { x, y: y + step, dx: 0, dy: step }   // Bas\n  ];\n  return moves.filter(n => \n    n.x >= 0 && \n    n.y >= 0 && \n    n.x < bound.width && \n    n.y < bound.height\n  );\n};\n\n// üîπ Fonction de mouvement adapt√©e\nconst mouvAStar = (bound: Size, hero: Coord) => {\n  let lastPath: Coord[] = [];\n  let lastGoal: Coord | null = null;\n  let isApproachingGoal = false;\n\n  return (ball: ObjectCercle) => {\n    const distanceToGoal = heuristique(ball.coord, hero);\n    \n    // Si on est d√©j√† assez proche, on va directement vers le goal\n    if (distanceToGoal <= 20) {\n      isApproachingGoal = true;\n      const dx = Math.sign(hero.x - ball.coord.x) * 4;\n      const dy = Math.sign(hero.y - ball.coord.y) * 4;\n      return {\n        ...ball,\n        coord: {\n          x: ball.coord.x + dx,\n          y: ball.coord.y + dy,\n          dx,\n          dy\n        }\n      };\n    }\n\n    // Recalcul du chemin seulement si n√©cessaire\n    if (!lastGoal || heuristique(hero, lastGoal) > 50 || lastPath.length === 0) {\n      lastPath = astar(ball.coord, hero, bound);\n      lastGoal = {...hero};\n      isApproachingGoal = false;\n    }\n\n    if (!isApproachingGoal && lastPath.length > 1) {\n      const nextStep = lastPath[1];\n      lastPath.shift();\n      \n      // Lissage du mouvement\n      const dx = nextStep.x - ball.coord.x;\n      const dy = nextStep.y - ball.coord.y;\n      \n      return {\n        ...ball,\n        coord: {\n          x: ball.coord.x + dx,\n          y: ball.coord.y + dy,\n          dx,\n          dy\n        }\n      };\n    }\n\n    // Fallback: mouvement direct si aucun chemin\n    const dx = Math.sign(hero.x - ball.coord.x) * 4;\n    const dy = Math.sign(hero.y - ball.coord.y) * 4;\n    return {\n      ...ball,\n      coord: {\n        x: ball.coord.x + dx,\n        y: ball.coord.y + dy,\n        dx,\n        dy\n      }\n    };\n  };\n};\n\n/*export const click =\n  (state: State) =>\n  (event: PointerEvent): State => {\n    const { offsetX, offsetY } = event\n    const target = state.pos.find(\n      (p) =>\n        dist2(p.coord, { x: offsetX, y: offsetY, dx: 0, dy: 0 }) <\n        Math.pow(conf.RADIUS, 2) + 100\n    )\n    if (target) {\n      target.coord.dx += Math.random() * 10\n      target.coord.dy += Math.random() * 10\n    }\n    return state\n  }*/\n\n\nconst collideBOC = (b:Coord, oc:ObjectCercle) => \n  dist2(b, {x: oc.coord.x, y: oc.coord.y, dx: 0, dy: 0}) < Math.pow(conf.RADIUS+oc.radius, 2)\n\nconst collideROC = (h: Hero, oc: ObjectCercle) => {\n  const hx = h.coord.x;\n  const hy = h.coord.y;\n  const hw = h.hitBox.hx;\n  const hh = h.hitBox.hy;\n  const cx = oc.coord.x;\n  const cy = oc.coord.y;\n  const cr = oc.radius;\n  const nearestX = Math.max(hx - hw / 2, Math.min(cx, hx + hw / 2));\n  const nearestY = Math.max(hy - hh / 2, Math.min(cy, hy + hh / 2));\n  const distX = cx - nearestX;\n  const distY = cy - nearestY;\n  return (distX * distX + distY * distY) <= (cr * cr);\n};\n  \nconst collideHeroTir = (h: Hero, oc: Ball) => {\n  const hx = h.coord.x;\n  const hy = h.coord.y;\n  const hw = h.hitBox.hx;\n  const hh = h.hitBox.hy;\n  const cx = oc.coord.x;\n  const cy = oc.coord.y;\n  const cr = 5;\n  const nearestX = Math.max(hx - hw / 2, Math.min(cx, hx + hw / 2));\n  const nearestY = Math.max(hy - hh / 2, Math.min(cy, hy + hh / 2));\n  const distX = cx - nearestX;\n  const distY = cy - nearestY;\n  return (distX * distX + distY * distY) <= (cr * cr);\n};\n\nconst collideEnnemieTir = (h: Rectangle, oc: Ball) => {\n  const hx = h.coord.x;\n  const hy = h.coord.y;\n  const hw = h.width;\n  const hh = h.height;\n  const cx = oc.coord.x;\n  const cy = oc.coord.y;\n  const cr = 5;\n  const nearestX = Math.max(hx, Math.min(cx, hx + hw));\n  const nearestY = Math.max(hy, Math.min(cy, hy + hh));\n  const distX = cx - nearestX;\n  const distY = cy - nearestY;\n  return (distX * distX + distY * distY) <= (cr * cr);\n};\n  \nconst collideBORR = (b:Coord, or:Wall) => \n  ((dist2(b, {x: or.rightBottom.x, y: or.leftTop.y, dx: 0, dy: 0}) < Math.pow(conf.RADIUS, 2)) || \n  (dist2(b, {x: or.rightBottom.x, y: or.rightBottom.y, dx: 0, dy: 0}) < Math.pow(conf.RADIUS, 2))) || \n  (dist2(b, {x: or.rightBottom.x, y:b.y, dx:0, dy:0}) < Math.pow(conf.RADIUS,2) && b.y > or.leftTop.y && b.y < or.rightBottom.y)\n\nconst collideBORL = (b:Coord, or: Wall) => \n  (dist2(b, {x: or.leftTop.x, y: or.rightBottom.y, dx: 0, dy: 0}) < Math.pow(conf.RADIUS, 2)) || \n  (dist2(b, {x: or.leftTop.x, y: or.leftTop.y, dx: 0, dy: 0}) < Math.pow(conf.RADIUS, 2)) || \n  (dist2(b, {x: or.leftTop.x, y:b.y, dx:0, dy:0}) < Math.pow(conf.RADIUS,2) && b.y > or.leftTop.y && b.y < or.rightBottom.y)\n\nconst collideBORU = (b:Coord, or:Wall) =>\n  (dist2(b, {x: or.rightBottom.x, y: or.leftTop.y, dx: 0, dy: 0}) < Math.pow(conf.RADIUS, 2)) || \n  (dist2(b, {x: or.leftTop.x, y: or.leftTop.y, dx: 0, dy: 0}) < Math.pow(conf.RADIUS, 2)) || \n  (dist2(b, {x: b.x, y:or.leftTop.y, dx:0, dy:0}) < Math.pow(conf.RADIUS,2) && b.x > or.leftTop.x && b.x < or.rightBottom.x) \n\n\nconst collideBORB = (b:Coord, or:Wall) =>\n  (dist2(b, {x: or.leftTop.x, y: or.rightBottom.y, dx: 0, dy: 0}) < Math.pow(conf.RADIUS, 2)) || \n  (dist2(b, {x: or.rightBottom.x, y: or.rightBottom.y, dx: 0, dy: 0}) < Math.pow(conf.RADIUS, 2)) || \n  (dist2(b, {x: b.x, y:or.rightBottom.y, dx:0, dy:0}) < Math.pow(conf.RADIUS,2) && b.x > or.leftTop.x && b.x < or.rightBottom.x) \n\n\nconst collide = (o1: Coord, o2: Coord) =>\n  dist2(o1, o2) < Math.pow(2 * conf.RADIUS, 2)\n\nconst collideboing = (p1: Coord, p2: Coord) => {\n  const nx = (p2.x - p1.x) / (2 * conf.RADIUS)\n  const ny = (p2.y - p1.y) / (2 * conf.RADIUS)\n  const gx = -ny\n  const gy = nx\n\n  const v1g = gx * p1.dx + gy * p1.dy\n  const v2n = nx * p2.dx + ny * p2.dy\n  const v2g = gx * p2.dx + gy * p2.dy\n  const v1n = nx * p1.dx + ny * p1.dy\n  p1.dx = nx * v2n + gx * v1g\n  p1.dy = ny * v2n + gy * v1g\n  p2.dx = nx * v1n + gx * v2g\n  p2.dy = ny * v1n + gy * v2g\n  p1.x += p1.dx\n  p1.y += p1.dy\n  p2.x += p2.dx\n  p2.y += p2.dy\n}\n\nconst collideboingS = (p1: Coord, p2:ObjectCercle) => {\n  const nx = (p2.coord.x-p1.x) / (2 * conf.RADIUS)\n  const ny = (p2.coord.y-p1.y) / (2 * conf.RADIUS)\n  const gx = -ny\n  const gy = nx\n\n  const v1g = gx * p1.dx + gy * p1.dy\n  const v1n = nx * p1.dx + ny * p1.dy\n  p1.dx -= 2 * nx  + gx * v1g\n  p1.dy -= 2 * ny  + gy * v1g\n  p1.x += p1.dx\n  p1.y += p1.dy\n  \n}\n\nexport const step = (state: State) => {\n    \n  // Gestion du d√©lai de tir\n  const shootingDelay = 60; \n\n  if (state.shootCooldownHero <= 0) {\n    state.tirs.push({\n      life: 1,\n      coord: {\n        x: state.hero.coord.x,\n        y: state.hero.coord.y,\n        dx: 0,\n        dy: -2,\n      },\n    });\n    state.shootCooldownHero = shootingDelay;\n  } else {\n    state.shootCooldownHero--;\n  }\n\n  state.ennemisQuiTire = state.ennemisQuiTire.map(([cooldown, ennemie]:[number, Rectangle]) =>{\n    if (ennemie.coord.y == 200){\n      if (cooldown <= 0) {\n        state.tirsEnnemie.push({\n          life:1,\n        coord: {\n          x: ennemie.coord.x+25,\n          y: ennemie.coord.y+50,\n          dx: 0,\n          dy: 2,\n        },\n        })\n        return [150, ennemie];\n      }\n      return [cooldown-1, ennemie];\n    }\n    return [cooldown, ennemie];\n  }\n)\n\n\n  \n  //Gestion du d√©lai d'apparition d'ennemis\n  const appearanceDelay = 100;\n  if (state.ennemyDelay <= 0) {\n    \n    switch (randomInt(2)){\n\n      case 5 :\n        //possibilit√© d'algo de gravit√©\n        state.debris.push(\n          {coord:{\n            x: randomInt(window.innerWidth - (120+(2*conf.BOUNDLEFT))) + (60+conf.BOUNDLEFT),\n            y: 0,\n            dx:0, \n            dy:2},\n          radius : 25,\n          life : 2 // faire un truc en fonction du rayon pour la vie\n        });\n        break;\n\n      case 5 :\n        state.ennemisQuiTire.push([ \n          150,\n          {coord: {\n            x: randomInt(window.innerWidth - (120+(2*conf.BOUNDLEFT))) + (60+conf.BOUNDLEFT),\n            y: 0,\n            dx:0, \n            dy:1 },\n          width:50, \n          height:50, \n          life: 2 //possibilit√© de modifier la vie\n          }\n        ])\n        break;\n\n        case 1:\n          state.ennemisVersHero.push(\n            {coord:{\n              x: randomInt(window.innerWidth - (120+(2*conf.BOUNDLEFT))) + (60+conf.BOUNDLEFT),\n              y: 0,\n              dx:0, \n              dy:2},\n            radius : 25,\n            life : 2 // faire un truc en fonction du rayon pour la vie\n          });\n          break;\n\n      default : \n        break\n\n    }\n    \n    state.ennemyDelay = appearanceDelay;\n  } else {\n    state.ennemyDelay--;\n  }\n\n  //Collision d√©bris - tir\n  state.tirs.map((p1) => {\n    state.debris.map((c) => {\n      if (collideBOC(p1.coord, c)){\n        p1.life--\n        c.life--\n      }\n    })\n  })\n\n  state.tirsEnnemie.map((p) => {\n    const coordH = state.hero.coord\n    if (collideHeroTir(state.hero, p)){\n      p.life = 0;\n      state.hero.vie --;\n    }\n  })\n\n  state.ennemisQuiTire.map(([_,r]) => {\n    state.tirs.map((p)=> {\n      if (collideEnnemieTir(r, p)){\n        r.life--;\n        p.life = 0;\n      }\n    })\n  })\n\n\n  if(state.hero.vie == 0) {\n    state.hero.coord.x =1\n    state.endOfGame = true\n  }\n\n  //Collision debri-h√©ros\n  state.debris.map((d) => {\n    if (collideROC(state.hero,d)) {\n      d.life = 0\n      state.hero.vie --;\n    }\n\n  })\n\n\n  return {\n    ...state,\n    tirs: state.tirs.map(iterate(state.size)).filter((p) => p.coord.y > 0 && p.life > 0),\n    tirsEnnemie: state.tirsEnnemie.map(iterate(state.size)).filter((p) => p.coord.y > 0 && p.life > 0),\n    debris: state.debris.map(mouvDebris(state.size)).filter((p) => p.coord.y < window.innerHeight && p.life > 0),\n    ennemisQuiTire: state.ennemisQuiTire.map(mouvTirD(state.size)).filter(([_, rect]) => rect.coord.y < window.innerHeight && rect.life > 0),\n    ennemisVersHero: state.ennemisVersHero.map(mouvAStar(state.size, state.hero.coord)).filter((p) => p.coord.y < window.innerHeight && p.life > 0),\n    endOfGame: state.endOfGame,\n  }\n}\n\nexport const handleKeyPress = \n  (state: State) =>\n    (event: KeyboardEvent):State => { \n        const stepx = state.hero.coord.dx;\n        const stepy = state.hero.coord.dy;\n        const ax = state.hero.coord.x;\n        const ay = state.hero.coord.y;\n        const hx = state.hero.hitBox.hx/2;\n        const hy = state.hero.hitBox.hy/2;\n        switch (event.key) {\n          case \"Z\":\n          case \"z\":\n            console.log(\"z\")\n            \n            if (ay - stepy - hy > state.limite[0].rightBottom.y){\n              return {...state, hero:{...state.hero, coord: {...state.hero.coord, y: ay - stepy}}}\n            }\n            return state;\n          case \"s\":\n          case \"S\":\n            console.log(\"s\")\n            if (ay + stepy+ hy< state.limite[3].leftTop.y){\n              return {...state, hero:{...state.hero, coord: {...state.hero.coord, y: ay + stepy}}}\n            }\n            return state;\n          case \"q\":\n          case \"Q\":\n            console.log(\"q\")\n            if (ax - stepx - hx> state.limite[1].rightBottom.x){\n              return {...state, hero:{...state.hero, coord: {...state.hero.coord, x: ax - stepx}}}\n            }\n            return state;\n          case \"d\":\n          case \"D\":\n            console.log(\"d\")\n            if (ax + stepx + hx < state.limite[2].leftTop.x){\n              return {...state, hero:{...state.hero, coord: {...state.hero.coord, x: ax + stepx}}}\n            }\n            return state;\n          default : \n            return state\n        }\n      }\n\nexport const mouseMove =\n  (state: State) =>\n  (event: PointerEvent): State => {\n    return state\n  }\n\nexport const endOfGame = (state: State): boolean => true\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}